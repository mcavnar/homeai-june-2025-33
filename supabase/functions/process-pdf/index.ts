import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const openAIApiKey = Deno.env.get('OPENAI_API_KEY');

// Text cleaning and filtering function
const cleanExtractedText = (rawText: string): string => {
  console.log('Starting text cleaning. Original length:', rawText.length);
  
  let cleanedText = rawText;
  
  // Remove binary/garbled characters and non-printable characters
  cleanedText = cleanedText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
  
  // Remove common PDF artifacts and metadata
  cleanedText = cleanedText.replace(/(?:Producer|Creator|CreationDate|ModDate|Title|Subject|Keywords):\s*[^\n]*/gi, '');
  
  // Split into lines for line-by-line filtering
  const lines = cleanedText.split('\n');
  const filteredLines = lines.filter(line => {
    const trimmedLine = line.trim();
    
    // Skip empty lines or lines with only whitespace
    if (trimmedLine.length === 0) return false;
    
    // Remove page headers/footers patterns
    if (/^page\s+\d+(\s+of\s+\d+)?$/i.test(trimmedLine)) return false;
    if (/^\d+\s*$/.test(trimmedLine) && trimmedLine.length < 4) return false; // Standalone page numbers
    
    // Remove common header/footer patterns
    if (/^(home inspection|inspection report|property inspection)/i.test(trimmedLine) && trimmedLine.length < 50) return false;
    if (/^(report date|inspection date|client|inspector)/i.test(trimmedLine) && trimmedLine.length < 80) return false;
    
    // Remove copyright and legal disclaimers
    if (/copyright|Â©|\(c\)|all rights reserved|proprietary|confidential/i.test(trimmedLine)) return false;
    if (/this report|liability|warranty|disclaimer|limitation/i.test(trimmedLine) && trimmedLine.length > 100) return false;
    
    // Remove contact information patterns
    if (/^(phone|tel|fax|email|website|www\.|http)/i.test(trimmedLine)) return false;
    if (/\b\d{3}[-.)]\s*\d{3}[-.)]\s*\d{4}\b/.test(trimmedLine) && trimmedLine.length < 50) return false; // Phone numbers
    
    // Remove navigation elements
    if (/^(table of contents|index|contents|summary|overview)$/i.test(trimmedLine)) return false;
    if (/^(continued|see page|page \d+)/i.test(trimmedLine)) return false;
    
    // Remove lines that are mostly special characters or formatting
    if (/^[^\w\s]*$/.test(trimmedLine)) return false;
    if (trimmedLine.length > 5 && /^[_\-=.*#]{5,}$/.test(trimmedLine)) return false;
    
    // Remove common PDF generation artifacts
    if (/^(generated by|created with|pdf|adobe)/i.test(trimmedLine) && trimmedLine.length < 50) return false;
    
    return true;
  });
  
  // Rejoin the filtered lines
  cleanedText = filteredLines.join('\n');
  
  // Remove excessive whitespace
  cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // Replace 3+ line breaks with 2
  cleanedText = cleanedText.replace(/[ \t]{2,}/g, ' '); // Replace multiple spaces/tabs with single space
  
  // Remove duplicate paragraphs (simple check for exact matches)
  const paragraphs = cleanedText.split('\n\n');
  const uniqueParagraphs = [];
  const seenParagraphs = new Set();
  
  for (const paragraph of paragraphs) {
    const trimmed = paragraph.trim();
    if (trimmed.length > 20 && !seenParagraphs.has(trimmed)) {
      seenParagraphs.add(trimmed);
      uniqueParagraphs.push(paragraph);
    } else if (trimmed.length <= 20) {
      uniqueParagraphs.push(paragraph); // Keep short paragraphs without deduplication
    }
  }
  
  cleanedText = uniqueParagraphs.join('\n\n').trim();
  
  console.log('Text cleaning completed. Cleaned length:', cleanedText.length);
  console.log('Size reduction:', ((rawText.length - cleanedText.length) / rawText.length * 100).toFixed(1) + '%');
  
  return cleanedText;
};

// OpenAI analysis function
const analyzeWithOpenAI = async (cleanedText: string) => {
  if (!openAIApiKey) {
    throw new Error('OpenAI API key not configured');
  }

  console.log('Starting OpenAI analysis. Text length:', cleanedText.length);

  const systemPrompt = `You are an expert home inspector and real estate professional. Analyze home inspection reports and provide structured, actionable insights that help homeowners understand what needs attention and how much it might cost.

Your analysis should be:
- Practical and specific
- Focused on safety and financial impact
- Helpful for prioritizing repairs
- Based on realistic cost estimates for typical markets

Return your response as valid JSON matching this exact structure (no markdown, no code blocks, just pure JSON):

{
  "propertyInfo": {
    "address": "extracted property address if found",
    "inspectionDate": "extracted inspection date if found"
  },
  "executiveSummary": [
    "exactly 5 clear, actionable bullet points summarizing the overall condition",
    "focus on the most important findings",
    "include cost implications where relevant",
    "keep each point concise but informative",
    "prioritize safety and major expenses"
  ],
  "majorSystems": {
    "roof": "brief assessment",
    "foundation": "brief assessment", 
    "electrical": "brief assessment",
    "plumbing": "brief assessment",
    "hvac": "brief assessment"
  },
  "issues": [
    {
      "description": "specific issue description",
      "location": "where in the house",
      "priority": "high or medium",
      "estimatedCost": {
        "min": number,
        "max": number
      },
      "category": "system category (e.g., Electrical, Plumbing, Structural)"
    }
  ],
  "safetyIssues": [
    "list of specific safety concerns that need immediate attention"
  ],
  "costSummary": {
    "highPriorityTotal": {"min": number, "max": number},
    "mediumPriorityTotal": {"min": number, "max": number}, 
    "grandTotal": {"min": number, "max": number}
  }
}`;

  const userPrompt = `Please analyze this home inspection report and extract the structured information requested. Focus on being specific about issues, their locations, realistic cost estimates, and actionable priorities.

Here is the inspection report text:

${cleanedText}`;

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openAIApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.3,
        max_tokens: 4000,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenAI API error:', response.status, errorText);
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    console.log('OpenAI response received');
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      throw new Error('Invalid response format from OpenAI');
    }

    const content = data.choices[0].message.content;
    console.log('Parsing OpenAI response...');
    
    try {
      const analysis = JSON.parse(content);
      console.log('Successfully parsed OpenAI analysis');
      return analysis;
    } catch (parseError) {
      console.error('Failed to parse OpenAI response as JSON:', parseError);
      console.error('Raw content:', content);
      throw new Error('Failed to parse AI analysis response');
    }

  } catch (error) {
    console.error('OpenAI analysis error:', error);
    throw new Error(`AI analysis failed: ${error.message}`);
  }
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { extractedText } = await req.json();
    
    if (!extractedText || typeof extractedText !== 'string') {
      throw new Error('No extracted text provided');
    }

    console.log('Processing extracted text. Original length:', extractedText.length);

    // Clean and filter the extracted text
    const cleanedText = cleanExtractedText(extractedText);

    if (cleanedText.length < 100) {
      throw new Error('Insufficient text content after cleaning for meaningful analysis');
    }

    // Analyze with OpenAI
    const analysis = await analyzeWithOpenAI(cleanedText);

    return new Response(
      JSON.stringify({
        success: true,
        analysis,
        cleanedText, // Include the cleaned text in the response
        extractedTextLength: extractedText.length,
        cleanedTextLength: cleanedText.length
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error processing extracted text:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
