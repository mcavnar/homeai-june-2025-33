
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Text cleaning and filtering function
const cleanExtractedText = (rawText: string): string => {
  console.log('Starting text cleaning. Original length:', rawText.length);
  
  let cleanedText = rawText;
  
  // Remove binary/garbled characters and non-printable characters
  cleanedText = cleanedText.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
  
  // Remove common PDF artifacts and metadata
  cleanedText = cleanedText.replace(/(?:Producer|Creator|CreationDate|ModDate|Title|Subject|Keywords):\s*[^\n]*/gi, '');
  
  // Split into lines for line-by-line filtering
  const lines = cleanedText.split('\n');
  const filteredLines = lines.filter(line => {
    const trimmedLine = line.trim();
    
    // Skip empty lines or lines with only whitespace
    if (trimmedLine.length === 0) return false;
    
    // Remove page headers/footers patterns
    if (/^page\s+\d+(\s+of\s+\d+)?$/i.test(trimmedLine)) return false;
    if (/^\d+\s*$/.test(trimmedLine) && trimmedLine.length < 4) return false; // Standalone page numbers
    
    // Remove common header/footer patterns
    if (/^(home inspection|inspection report|property inspection)/i.test(trimmedLine) && trimmedLine.length < 50) return false;
    if (/^(report date|inspection date|client|inspector)/i.test(trimmedLine) && trimmedLine.length < 80) return false;
    
    // Remove copyright and legal disclaimers
    if (/copyright|Â©|\(c\)|all rights reserved|proprietary|confidential/i.test(trimmedLine)) return false;
    if (/this report|liability|warranty|disclaimer|limitation/i.test(trimmedLine) && trimmedLine.length > 100) return false;
    
    // Remove contact information patterns
    if (/^(phone|tel|fax|email|website|www\.|http)/i.test(trimmedLine)) return false;
    if (/\b\d{3}[-.)]\s*\d{3}[-.)]\s*\d{4}\b/.test(trimmedLine) && trimmedLine.length < 50) return false; // Phone numbers
    
    // Remove navigation elements
    if (/^(table of contents|index|contents|summary|overview)$/i.test(trimmedLine)) return false;
    if (/^(continued|see page|page \d+)/i.test(trimmedLine)) return false;
    
    // Remove lines that are mostly special characters or formatting
    if (/^[^\w\s]*$/.test(trimmedLine)) return false;
    if (trimmedLine.length > 5 && /^[_\-=.*#]{5,}$/.test(trimmedLine)) return false;
    
    // Remove common PDF generation artifacts
    if (/^(generated by|created with|pdf|adobe)/i.test(trimmedLine) && trimmedLine.length < 50) return false;
    
    return true;
  });
  
  // Rejoin the filtered lines
  cleanedText = filteredLines.join('\n');
  
  // Remove excessive whitespace
  cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // Replace 3+ line breaks with 2
  cleanedText = cleanedText.replace(/[ \t]{2,}/g, ' '); // Replace multiple spaces/tabs with single space
  
  // Remove duplicate paragraphs (simple check for exact matches)
  const paragraphs = cleanedText.split('\n\n');
  const uniqueParagraphs = [];
  const seenParagraphs = new Set();
  
  for (const paragraph of paragraphs) {
    const trimmed = paragraph.trim();
    if (trimmed.length > 20 && !seenParagraphs.has(trimmed)) {
      seenParagraphs.add(trimmed);
      uniqueParagraphs.push(paragraph);
    } else if (trimmed.length <= 20) {
      uniqueParagraphs.push(paragraph); // Keep short paragraphs without deduplication
    }
  }
  
  cleanedText = uniqueParagraphs.join('\n\n').trim();
  
  console.log('Text cleaning completed. Cleaned length:', cleanedText.length);
  console.log('Size reduction:', ((rawText.length - cleanedText.length) / rawText.length * 100).toFixed(1) + '%');
  
  return cleanedText;
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { extractedText } = await req.json();
    
    if (!extractedText || typeof extractedText !== 'string') {
      throw new Error('No extracted text provided');
    }

    console.log('Processing extracted text. Original length:', extractedText.length);

    // Clean and filter the extracted text
    const cleanedText = cleanExtractedText(extractedText);

    // Return the cleaned text for verification
    const analysis = {
      summary: cleanedText, // Show the cleaned text
      fullTextLength: extractedText.length,
      cleanedTextLength: cleanedText.length,
    };

    return new Response(
      JSON.stringify({
        success: true,
        analysis,
        extractedTextLength: extractedText.length,
        cleanedTextLength: cleanedText.length
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Error processing extracted text:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
